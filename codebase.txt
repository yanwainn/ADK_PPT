
Google Agent Developer Kit
Private
Google Agent Developer Kit learning and building multi agent examples




Start a chat to keep conversations organized and re-use project knowledge.
Project knowledge
2% of project capacity used

codebase.txt
2,158 lines

txt



Project_description.md
91 lines

md



codebase.txt

92.55 KB â€¢2,158 lines
â€¢
Formatting may be inconsistent from source

â”œâ”€â”€ app.py
â”œâ”€â”€ modules
    â”œâ”€â”€ agents.py
    â”œâ”€â”€ helpers.py
    â”œâ”€â”€ models.py
    â”œâ”€â”€ pptx_converter.py
    â”œâ”€â”€ processor.py
    â”œâ”€â”€ slide_generator.py
    â””â”€â”€ template_pptx_converter.py
â””â”€â”€ utils
    â”œâ”€â”€ logo_test.py
    â””â”€â”€ openai_client.py


/app.py:
--------------------------------------------------------------------------------
  1 | """
  2 | PDF to HTML Presentation Generator - Main Streamlit Application.
  3 | 
  4 | This application transforms PDFs into HTML presentations with AI-generated images.
  5 | """
  6 | import os
  7 | import asyncio
  8 | import zipfile
  9 | import streamlit as st
 10 | from io import BytesIO
 11 | from dotenv import load_dotenv
 12 | 
 13 | from modules.processor import process_pdf_to_presentation
 14 | from utils.openai_client import update_openai_settings
 15 | 
 16 | # Load environment variables
 17 | load_dotenv()
 18 | 
 19 | # Page configuration
 20 | st.set_page_config(page_title="PDF to Presentation", page_icon="ðŸ–¼ï¸", layout="wide")
 21 | 
 22 | # ===== INITIALIZE SESSION STATES =====
 23 | def initialize_session_states():
 24 |     """Initialize all session state variables."""
 25 |     if 'pdf_content' not in st.session_state:
 26 |         st.session_state.pdf_content = None
 27 |     if 'key_sections' not in st.session_state:
 28 |         st.session_state.key_sections = None
 29 |     if 'image_prompts' not in st.session_state:
 30 |         st.session_state.image_prompts = []
 31 |     if 'generated_images' not in st.session_state:
 32 |         st.session_state.generated_images = []
 33 |     if 'slides_html' not in st.session_state:
 34 |         st.session_state.slides_html = []
 35 |     if 'process_complete' not in st.session_state:
 36 |         st.session_state.process_complete = False
 37 |     if 'images_folder' not in st.session_state:
 38 |         st.session_state.images_folder = os.path.join(os.getcwd(), 'generated_images')
 39 |     if 'uploaded_template' not in st.session_state:
 40 |         st.session_state.uploaded_template = None
 41 | 
 42 | # ===== SETTINGS SIDEBAR CONTENT =====
 43 | def render_settings_sidebar():
 44 |     """Render the settings sidebar."""
 45 |     with st.sidebar:
 46 |         st.header("Settings")
 47 |         
 48 |         # Image folder
 49 |         st.subheader("Image Output Folder")
 50 |         images_folder = st.text_input("Path to save images", value=st.session_state.images_folder)
 51 |         
 52 |         if st.button("Update Folder"):
 53 |             try:
 54 |                 os.makedirs(images_folder, exist_ok=True)
 55 |                 st.session_state.images_folder = images_folder
 56 |                 st.success(f"Image folder updated")
 57 |             except Exception as e:
 58 |                 st.error(f"Error: {str(e)}")
 59 |         
 60 |         # API Configuration
 61 |         with st.expander("API Settings"):
 62 |             # GPT settings
 63 |             st.markdown("**GPT Settings**")
 64 |             gpt_api_key = st.text_input("Azure OpenAI API Key", value=os.getenv("AZURE_OPENAI_API_KEY", ""), type="password")
 65 |             gpt_endpoint = st.text_input("Azure OpenAI Endpoint", value=os.getenv("AZURE_OPENAI_ENDPOINT", ""))
 66 |             gpt_deployment = st.text_input("Azure OpenAI Deployment", value=os.getenv("AZURE_OPENAI_DEPLOYMENT", ""))
 67 |             gpt_api_version = st.text_input("API Version", value=os.getenv("AZURE_OPENAI_API_VERSION", "2024-02-01"))
 68 |             
 69 |             # DALL-E settings
 70 |             st.markdown("**DALL-E Settings**")
 71 |             dalle_api_key = st.text_input("DALL-E API Key", value=os.getenv("DALLE_API_KEY", ""), type="password")
 72 |             dalle_endpoint = st.text_input("DALL-E Endpoint", value=os.getenv("DALLE_ENDPOINT", ""))
 73 |             dalle_api_version = st.text_input("API Version", value=os.getenv("DALLE_API_VERSION", "2024-02-01"))
 74 |             dalle_deployment = st.text_input("Deployment Name", value=os.getenv("DALLE_DEPLOYMENT", "dall-e-3"))
 75 |             
 76 |             if st.button("Update API Settings"):
 77 |                 # Update environment variables using the central function
 78 |                 gpt_settings = {
 79 |                     "api_key": gpt_api_key,
 80 |                     "endpoint": gpt_endpoint,
 81 |                     "deployment": gpt_deployment,
 82 |                     "api_version": gpt_api_version
 83 |                 }
 84 |                 dalle_settings = {
 85 |                     "api_key": dalle_api_key,
 86 |                     "endpoint": dalle_endpoint,
 87 |                     "api_version": dalle_api_version,
 88 |                     "deployment": dalle_deployment
 89 |                 }
 90 |                 update_openai_settings(gpt_settings, dalle_settings)
 91 |                 st.success("API settings updated")
 92 | 
 93 | # ===== MAIN CONTENT AREA =====
 94 | def render_main_content():
 95 |     """Render the main content area."""
 96 |     st.title("Ask Presenta")
 97 |     st.markdown("Transform PDFs into PowerPoint presentations with Agentic-AI.")
 98 |     
 99 |     # File upload
100 |     st.subheader("Upload Your PDF Document")
101 |     uploaded_file = st.file_uploader("Choose a PDF file", type="pdf")
102 |     
103 |     if uploaded_file is not None:
104 |         st.write(f"Uploaded: {uploaded_file.name}")
105 |         
106 |         # Process button
107 |         if st.button("Generate Presentation", use_container_width=True):
108 |             with st.spinner("Processing..."):
109 |                 asyncio.run(process_pdf_to_presentation(uploaded_file))
110 | 
111 | # ===== RESULTS DISPLAY =====
112 | def render_results():
113 |     """Render the results if process is complete."""
114 |     if st.session_state.process_complete:
115 |         extraction_result = st.session_state.key_sections
116 |         prompts = st.session_state.image_prompts
117 |         images = st.session_state.generated_images
118 |         slides = st.session_state.slides_html
119 |         
120 |         # Document overview
121 |         st.subheader("Document Analysis")
122 |         st.write(f"**Document:** {extraction_result.document_title}")
123 |         st.write(f"**Summary:** {extraction_result.summary}")
124 |         
125 |         # Hide the generated images section
126 |         # Directly show the presentation slides
127 |         
128 |         st.subheader("Presentation")
129 |         if len(slides) > 0:
130 |             # Create tabs for different outputs
131 |             preview_tab, download_tab = st.tabs(["Preview Slides", "Download Options"])
132 |             
133 |             with preview_tab:
134 |                 # Create slide navigation
135 |                 slide_tabs = []
136 |                 for i, slide in enumerate(slides):
137 |                     slide_tabs.append(f"{i+1}. {slide.title}")
138 |                 
139 |                 selected_tab = st.radio("Select slide:", slide_tabs, horizontal=True)
140 |                 selected_index = slide_tabs.index(selected_tab)
141 |                 
142 |                 # Preview selected slide
143 |                 if selected_index < len(slides):
144 |                     selected_slide = slides[selected_index]
145 |                     
146 |                     # Show HTML slide
147 |                     st.markdown("<div class='slide-container'>", unsafe_allow_html=True)
148 |                     st.components.v1.html(selected_slide.html_content, height=600, scrolling=False)
149 |                     st.markdown("</div>", unsafe_allow_html=True)
150 |             
151 |             with download_tab:
152 |                 # PowerPoint and HTML download options
153 |                 ppt_col, html_col = st.columns(2)
154 |                 
155 |                 with ppt_col:
156 |                     st.markdown("### PowerPoint Presentation")
157 |                     
158 |                     # Check if we have a template file
159 |                     template_file = None
160 |                     template_paths = [
161 |                         os.path.join(os.getcwd(), "template.pptx"),
162 |                         os.path.join(os.getcwd(), "templates", "template.pptx"),
163 |                         os.path.join(os.getcwd(), "static", "template.pptx")
164 |                     ]
165 |                     
166 |                     for path in template_paths:
167 |                         if os.path.exists(path):
168 |                             template_file = path
169 |                             break
170 |                     
171 |                     # Template upload option
172 |                     st.markdown("#### PowerPoint Template")
173 |                     template_upload = st.file_uploader("Upload your organization's PowerPoint template", type="pptx")
174 |                     
175 |                     if template_upload is not None:
176 |                         # Save the uploaded template to session state
177 |                         template_bytes = template_upload.getvalue()
178 |                         st.session_state.uploaded_template = BytesIO(template_bytes)
179 |                         st.success(f"Template '{template_upload.name}' uploaded successfully!")
180 |                     
181 |                     # Template selection
182 |                     use_template = False
183 |                     template_source = "None"
184 |                     
185 |                     if st.session_state.uploaded_template is not None:
186 |                         use_template = st.checkbox("Use uploaded PowerPoint template", value=True)
187 |                         if use_template:
188 |                             template_source = "uploaded"
189 |                     elif template_file:
190 |                         use_template = st.checkbox("Use organization PowerPoint template", value=True)
191 |                         if use_template:
192 |                             template_source = "default"
193 |                             st.caption(f"Using template: {os.path.basename(template_file)}")
194 |                     
195 |                     # Generate PowerPoint button
196 |                     if st.button("Generate PowerPoint Presentation", use_container_width=True):
197 |                         with st.spinner("Creating PowerPoint..."):
198 |                             try:
199 |                                 pptx_buffer = None
200 |                                 
201 |                                 if use_template:
202 |                                     # Use template-based converter
203 |                                     from modules.template_pptx_converter import create_powerpoint_from_template
204 |                                     
205 |                                     if template_source == "uploaded" and st.session_state.uploaded_template is not None:
206 |                                         # Use the uploaded template
207 |                                         pptx_buffer = create_powerpoint_from_template(
208 |                                             slides, 
209 |                                             extraction_result, 
210 |                                             template_file=None,
211 |                                             template_stream=st.session_state.uploaded_template
212 |                                         )
213 |                                     elif template_source == "default" and template_file:
214 |                                         # Use the default template file
215 |                                         pptx_buffer = create_powerpoint_from_template(
216 |                                             slides, 
217 |                                             extraction_result, 
218 |                                             template_file=template_file
219 |                                         )
220 |                                     else:
221 |                                         raise ValueError("Template selected but not available")
222 |                                 else:
223 |                                     # Use standard converter
224 |                                     from modules.pptx_converter import create_powerpoint_from_slides
225 |                                     pptx_buffer = create_powerpoint_from_slides(slides, extraction_result)
226 |                                 
227 |                                 # Display success message
228 |                                 st.success("PowerPoint presentation created successfully!")
229 |                                 
230 |                                 # Download button for PowerPoint
231 |                                 st.download_button(
232 |                                     label="Download PowerPoint Presentation",
233 |                                     data=pptx_buffer.getvalue(),
234 |                                     file_name=f"{extraction_result.document_title}.pptx",
235 |                                     mime="application/vnd.openxmlformats-officedocument.presentationml.presentation",
236 |                                     use_container_width=True
237 |                                 )
238 |                             except Exception as e:
239 |                                 st.error(f"Error creating PowerPoint: {str(e)}")
240 |                                 st.info("Make sure you have the 'python-pptx' library installed: `pip install python-pptx`")
241 |                 
242 |                     # Template info
243 |                     if not template_file and st.session_state.uploaded_template is None:
244 |                         st.info("You can upload your organization's PowerPoint template above, or add a file named 'template.pptx' to your project folder.")
245 |                         st.caption("The template should include slide layouts for a title slide and content slides.")
246 | 
247 |                 with html_col:
248 |                     st.markdown("### HTML Slides")
249 |                     # Create zip file for HTML slides
250 |                     zip_buffer = BytesIO()
251 |                     with zipfile.ZipFile(zip_buffer, "w", zipfile.ZIP_DEFLATED) as zip_file:
252 |                         for i, slide in enumerate(slides):
253 |                             file_name = f"slide_{i+1}_{slide.title.replace(' ', '_')}.html"
254 |                             zip_file.writestr(file_name, slide.html_content)
255 |                     
256 |                     # Download button for HTML zip
257 |                     st.download_button(
258 |                         label="Download All HTML Slides (ZIP)",
259 |                         data=zip_buffer.getvalue(),
260 |                         file_name="presentation_slides_html.zip",
261 |                         mime="application/zip",
262 |                         use_container_width=True
263 |                     )
264 |                     
265 |                     # Option to download individual slide
266 |                     st.markdown("#### Download Individual Slide")
267 |                     slide_select = st.selectbox(
268 |                         "Select a slide to download:",
269 |                         [f"{i+1}. {slide.title}" for i, slide in enumerate(slides)]
270 |                     )
271 |                     selected_index = [f"{i+1}. {slide.title}" for i, slide in enumerate(slides)].index(slide_select)
272 |                     
273 |                     if selected_index >= 0:
274 |                         selected_slide = slides[selected_index]
275 |                         st.download_button(
276 |                             label=f"Download '{selected_slide.title}' Slide",
277 |                             data=selected_slide.html_content,
278 |                             file_name=f"slide_{selected_index+1}_{selected_slide.title.replace(' ', '_')}.html",
279 |                             mime="text/html",
280 |                             use_container_width=True
281 |                         )
282 | 
283 | 
284 | # ===== MAIN APPLICATION =====
285 | def main():
286 |     """Main application entry point."""
287 |     # Initialize session states
288 |     initialize_session_states()
289 |     
290 |     # Render sidebar
291 |     render_settings_sidebar()
292 |     
293 |     # Render main content
294 |     render_main_content()
295 |     
296 |     # Render results if available
297 |     render_results()
298 | 
299 | if __name__ == "__main__":
300 |     main()


--------------------------------------------------------------------------------
/modules/agents.py:
--------------------------------------------------------------------------------
  1 | """
  2 | OpenAI agent definitions and configurations.
  3 | """
  4 | import os
  5 | from agents import Agent, Runner
  6 | from openai import AsyncAzureOpenAI
  7 | from modules.models import ContentExtractionResult, VisualPrompt
  8 | 
  9 | def create_content_extraction_agent():
 10 |     """
 11 |     Agent to extract key sections from the PDF.
 12 |     
 13 |     Returns:
 14 |         Agent: Content extraction agent
 15 |     """
 16 |     extraction_instructions = """Extract 3-7 key sections from this document that would be excellent for presentation slides.
 17 |     For each section:
 18 |     1. Create a clear title
 19 |     2. Extract/summarize essential content (200-300 words max)
 20 |     3. Rate importance (1-10)
 21 |     4. Identify 3-5 key themes
 22 |     5. List 3-7 visual elements for an image
 23 |     
 24 |     Also provide:
 25 |     - Document title
 26 |     - Brief document summary (3-5 sentences)
 27 |     - 3-5 overall themes
 28 |     
 29 |     Focus on sections with clear visual potential that would work well for presentation slides.
 30 |     """
 31 | 
 32 |     return Agent(
 33 |         name="ContentExtractionAgent",
 34 |         instructions=extraction_instructions,
 35 |         model=os.getenv("AZURE_OPENAI_DEPLOYMENT"),
 36 |         output_type=ContentExtractionResult
 37 |     )
 38 | 
 39 | def create_visual_prompt_agent():
 40 |     """
 41 |     Agent to create DALL-E prompts.
 42 |     
 43 |     Returns:
 44 |         Agent: Visual prompt generation agent
 45 |     """
 46 |     prompt_instructions = """Create a premium photorealistic image prompt for DALL-E 3.
 47 |     Your prompt must:
 48 |     1. Be highly detailed and specific
 49 |     2. Specify photorealistic style (not cartoon/illustration)
 50 |     3. Include lighting, perspective, atmosphere details
 51 |     4. Focus on visual elements only (NO text/diagrams)
 52 |     5. Be under 200 words
 53 |     
 54 |     Also provide:
 55 |     1. Style guidance: Photography/artistic styles
 56 |     2. Elements to avoid: 3-5 things to exclude
 57 |     
 58 |     IMPORTANT:
 59 |     - NEVER include text in the image
 60 |     - Focus on physical, tangible elements
 61 |     - Create prompt for a SINGLE cohesive image
 62 |     """
 63 | 
 64 |     return Agent(
 65 |         name="VisualPromptAgent",
 66 |         instructions=prompt_instructions,
 67 |         model=os.getenv("AZURE_OPENAI_DEPLOYMENT"),
 68 |         output_type=VisualPrompt
 69 |     )
 70 | 
 71 | async def extract_key_sections(pdf_text):
 72 |     """
 73 |     Extract key sections from PDF text.
 74 |     
 75 |     Args:
 76 |         pdf_text (str): Text extracted from PDF
 77 |         
 78 |     Returns:
 79 |         ContentExtractionResult: Extraction results
 80 |     """
 81 |     extraction_agent = create_content_extraction_agent()
 82 |     
 83 |     if len(pdf_text) > 25000:
 84 |         pdf_text = pdf_text[:25000] + "\n\n[Content truncated due to length]"
 85 |     
 86 |     result = await Runner.run(extraction_agent, f"Document Content:\n\n{pdf_text}")
 87 |     return result.final_output
 88 | 
 89 | async def extract_key_bullet_points(section, document_title):
 90 |     """
 91 |     Extract concise bullet points from section content.
 92 |     
 93 |     Args:
 94 |         section: Section to extract bullet points from
 95 |         document_title (str): Document title
 96 |         
 97 |     Returns:
 98 |         list: List of bullet points
 99 |     """
100 |     # Use GPT directly for speed rather than the Agents framework
101 |     client = AsyncAzureOpenAI(
102 |         api_key=os.getenv("AZURE_OPENAI_API_KEY"),
103 |         api_version=os.getenv("AZURE_OPENAI_API_VERSION"),
104 |         azure_endpoint=os.getenv("AZURE_OPENAI_ENDPOINT"),
105 |         azure_deployment=os.getenv("AZURE_OPENAI_DEPLOYMENT")
106 |     )
107 |     
108 |     # Create the prompt for bullet point extraction
109 |     prompt = f"""Extract 3-5 extremely concise bullet points (5-10 words each) from this content.
110 | Each bullet point should capture a key insight using active, impactful language.
111 | 
112 | SECTION TITLE: {section.title}
113 | 
114 | CONTENT:
115 | {section.content}
116 | 
117 | KEY THEMES: {', '.join(section.themes)}
118 | 
119 | Format your response as a simple Python list of strings, like this:
120 | ["First bullet point", "Second bullet point", "Third bullet point"]
121 | 
122 | Make each bullet point extremely concise, starting with action verbs when possible.
123 | Focus on the most important facts, insights, or takeaways.
124 | """
125 |     
126 |     try:
127 |         response = await client.chat.completions.create(
128 |             model=os.getenv("AZURE_OPENAI_DEPLOYMENT"),
129 |             messages=[{"role": "user", "content": prompt}],
130 |             temperature=0.3,  # Lower temperature for more focused, consistent output
131 |             max_tokens=300
132 |         )
133 |         
134 |         # Extract the list of bullet points from the response
135 |         bullet_points_text = response.choices[0].message.content.strip()
136 |         
137 |         # Try to parse as a Python list
138 |         try:
139 |             # Use a safer alternative to eval
140 |             import ast
141 |             bullet_points = ast.literal_eval(bullet_points_text)
142 |             
143 |             # Make sure we got a list
144 |             if not isinstance(bullet_points, list):
145 |                 raise ValueError("Response is not a list")
146 |                 
147 |             # Ensure all elements are strings
148 |             bullet_points = [str(point) for point in bullet_points]
149 |             
150 |             # Limit to 5 bullet points maximum
151 |             bullet_points = bullet_points[:5]
152 |             
153 |             return bullet_points
154 |             
155 |         except (SyntaxError, ValueError) as e:
156 |             # Fallback if we can't parse the list - manually extract bullet points
157 |             print(f"Error parsing bullet points: {e}")
158 |             
159 |             # Try to extract bullet points with regex
160 |             import re
161 |             bullet_pattern = r'"([^"]+)"'
162 |             bullet_points = re.findall(bullet_pattern, bullet_points_text)
163 |             
164 |             if not bullet_points:
165 |                 # Try alternative pattern for non-quoted bullet points
166 |                 bullet_pattern = r'\[\s*(.+?)\s*\]'
167 |                 bullet_match = re.search(bullet_pattern, bullet_points_text)
168 |                 if bullet_match:
169 |                     # Split by commas
170 |                     bullet_points = [bp.strip().strip('"\'') for bp in bullet_match.group(1).split(',')]
171 |             
172 |             if not bullet_points:
173 |                 # Last resort - split by new lines and look for common bullet markers
174 |                 lines = bullet_points_text.split('\n')
175 |                 bullet_points = []
176 |                 for line in lines:
177 |                     line = line.strip()
178 |                     if line.startswith('-') or line.startswith('*') or (line.startswith('[') and ']' in line):
179 |                         # Clean up the bullet point
180 |                         cleaned = line.lstrip('-*[] ').rstrip(']').strip()
181 |                         if cleaned:
182 |                             bullet_points.append(cleaned)
183 |             
184 |             # If we still don't have bullet points, create basic ones from themes
185 |             if not bullet_points and section.themes:
186 |                 bullet_points = [f"Explores {theme}" for theme in section.themes[:5]]
187 |             
188 |             # Final fallback
189 |             if not bullet_points:
190 |                 # Create some generic bullet points based on the title
191 |                 bullet_points = [
192 |                     f"Highlights key aspects of {section.title}",
193 |                     f"Provides essential insights",
194 |                     f"Establishes important context"
195 |                 ]
196 |             
197 |             return bullet_points[:5]  # Limit to 5 bullet points
198 |             
199 |     except Exception as e:
200 |         print(f"Error extracting bullet points: {str(e)}")
201 |         # If all else fails, provide generic bullet points
202 |         return [
203 |             f"Explores {section.title}",
204 |             "Provides essential insights",
205 |             "Highlights key information"
206 |         ]
207 | 
208 | async def create_visual_prompt(section, document_title):
209 |     """
210 |     Create image prompt for a section.
211 |     
212 |     Args:
213 |         section: Section to create prompt for
214 |         document_title (str): Document title
215 |         
216 |     Returns:
217 |         VisualPrompt: Generated visual prompt
218 |     """
219 |     prompt_agent = create_visual_prompt_agent()
220 |     
221 |     input_text = (
222 |         f"Document Title: {document_title}\n\n"
223 |         f"Section Title: {section.title}\n\n"
224 |         f"Section Content:\n{section.content}\n\n"
225 |         f"Key Themes: {', '.join(section.themes)}\n\n"
226 |         f"Potential Visual Elements: {', '.join(section.visual_elements)}\n\n"
227 |         f"Create a photorealistic prompt for this content."
228 |     )
229 |     
230 |     result = await Runner.run(prompt_agent, input_text)
231 |     return result.final_output


--------------------------------------------------------------------------------
/modules/helpers.py:
--------------------------------------------------------------------------------
  1 | """
  2 | Helper functions for the PDF to Presentation application.
  3 | """
  4 | import os
  5 | import base64
  6 | import requests
  7 | import numpy as np
  8 | from io import BytesIO
  9 | from PIL import Image, ImageDraw, ImageFont
 10 | from datetime import datetime
 11 | import PyPDF2
 12 | import streamlit as st
 13 | 
 14 | from modules.models import ImageInfo
 15 | 
 16 | def extract_text_from_pdf(pdf_file):
 17 |     """
 18 |     Extract text content from PDF file.
 19 |     
 20 |     Args:
 21 |         pdf_file: The uploaded PDF file
 22 |         
 23 |     Returns:
 24 |         str: Extracted text or None if extraction failed
 25 |     """
 26 |     try:
 27 |         pdf_reader = PyPDF2.PdfReader(pdf_file)
 28 |         text = ""
 29 |         
 30 |         for page_num in range(len(pdf_reader.pages)):
 31 |             page = pdf_reader.pages[page_num]
 32 |             text += page.extract_text() + "\n\n"
 33 |             
 34 |             if len(text) > 50000:
 35 |                 text += "... [Content truncated due to length]"
 36 |                 break
 37 |                 
 38 |         return text
 39 |     except Exception as e:
 40 |         st.error(f"Error extracting text from PDF: {str(e)}")
 41 |         return None
 42 | 
 43 | def generate_image_from_prompt(client, prompt, size="1024x1024"):
 44 |     """
 45 |     Generate image using DALL-E.
 46 |     
 47 |     Args:
 48 |         client: DALL-E client
 49 |         prompt (str): Image generation prompt
 50 |         size (str): Image size (default: "1024x1024")
 51 |         
 52 |     Returns:
 53 |         dict: Dictionary with image, URL, and revised prompt
 54 |     """
 55 |     try:
 56 |         # Generate image with DALL-E
 57 |         try:
 58 |             response = client.images.generate(
 59 |                 model=os.getenv("DALLE_DEPLOYMENT", "dall-e-3"),
 60 |                 prompt=prompt,
 61 |                 n=1,
 62 |                 size=size
 63 |             )
 64 |             
 65 |             image_url = response.data[0].url
 66 |             image_data = requests.get(image_url).content
 67 |             image = Image.open(BytesIO(image_data))
 68 |             revised_prompt = getattr(response.data[0], 'revised_prompt', None)
 69 |             
 70 |             return {
 71 |                 "image": image,
 72 |                 "url": image_url,
 73 |                 "revised_prompt": revised_prompt
 74 |             }
 75 |             
 76 |         except Exception as dalle_error:
 77 |             # Create a placeholder gradient if DALL-E fails
 78 |             st.warning(f"Image generation failed: {str(dalle_error)}")
 79 |             
 80 |             width, height = map(int, size.split('x'))
 81 |             image = Image.new('RGB', (width, height), color='white')
 82 |             
 83 |             # Generate random colors based on the prompt
 84 |             def get_color_from_prompt(prompt_text):
 85 |                 hash_val = sum(ord(c) for c in prompt_text)
 86 |                 r = (hash_val * 123) % 256
 87 |                 g = (hash_val * 456) % 256
 88 |                 b = (hash_val * 789) % 256
 89 |                 return (r, g, b)
 90 |             
 91 |             # Create a gradient
 92 |             start_color = get_color_from_prompt(prompt[:10])
 93 |             end_color = get_color_from_prompt(prompt[-10:] if len(prompt) > 10 else prompt)
 94 |             
 95 |             arr = np.zeros((height, width, 3), dtype=np.uint8)
 96 |             for y in range(height):
 97 |                 for x in range(width):
 98 |                     r = int(start_color[0] * (width - x) / width + end_color[0] * x / width)
 99 |                     g = int(start_color[1] * (height - y) / height + end_color[1] * y / height)
100 |                     b = int(start_color[2] * (1 - (x + y) / (width + height)) + end_color[2] * (x + y) / (width + height))
101 |                     arr[y, x] = [r, g, b]
102 |             
103 |             image = Image.fromarray(arr)
104 |             
105 |             # Add a placeholder label
106 |             draw = ImageDraw.Draw(image)
107 |             try:
108 |                 font = ImageFont.truetype("arial.ttf", 40)
109 |             except:
110 |                 font = ImageFont.load_default()
111 |             
112 |             message = "Placeholder Image"
113 |             text_width = 200
114 |             text_position = ((width - text_width) // 2, height // 2)
115 |             draw.text((text_position[0]+2, text_position[1]+2), message, font=font, fill=(0, 0, 0))
116 |             draw.text(text_position, message, font=font, fill=(255, 255, 255))
117 |             
118 |             return {
119 |                 "image": image,
120 |                 "url": "placeholder_image_url",
121 |                 "revised_prompt": "Placeholder image due to API error",
122 |                 "is_placeholder": True
123 |             }
124 |             
125 |     except Exception as e:
126 |         st.error(f"Error in image generation: {str(e)}")
127 |         from random import randint
128 |         image = Image.new('RGB', (512, 512), color=(randint(0, 255), randint(0, 255), randint(0, 255)))
129 |         return {
130 |             "image": image,
131 |             "url": "error_placeholder_image_url",
132 |             "revised_prompt": f"Error occurred: {str(e)}",
133 |             "is_placeholder": True
134 |         }
135 | 
136 | def save_image_locally(image, section_title, index, images_folder):
137 |     """
138 |     Save generated image to a folder.
139 |     
140 |     Args:
141 |         image: PIL Image
142 |         section_title (str): Title of the section
143 |         index (int): Image index
144 |         images_folder (str): Path to save images
145 |         
146 |     Returns:
147 |         dict: Information about the saved image
148 |     """
149 |     try:
150 |         os.makedirs(images_folder, exist_ok=True)
151 |         
152 |         timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
153 |         clean_title = ''.join(c if c.isalnum() else '_' for c in section_title)
154 |         filename = f"{timestamp}_{index}_{clean_title}.png"
155 |         
156 |         filepath = os.path.join(images_folder, filename)
157 |         image.save(filepath, format="PNG")
158 |         
159 |         return {
160 |             "success": True,
161 |             "filepath": filepath,
162 |             "filename": filename
163 |         }
164 |     except Exception as e:
165 |         st.error(f"Error saving image: {str(e)}")
166 |         return {
167 |             "success": False,
168 |             "error": str(e)
169 |         }
170 | 
171 | def load_image_info_from_pil(image, filename, filepath):
172 |     """
173 |     Create ImageInfo from PIL Image.
174 |     
175 |     Args:
176 |         image: PIL Image
177 |         filename (str): Image filename
178 |         filepath (str): Full path to the image
179 |         
180 |     Returns:
181 |         ImageInfo: Image information or None if processing failed
182 |     """
183 |     try:
184 |         width, height = image.size
185 |         
186 |         # Convert to RGB if needed
187 |         if image.mode in ('RGBA', 'LA') or (image.mode == 'P' and 'transparency' in image.info):
188 |             background = Image.new('RGB', image.size, (255, 255, 255))
189 |             if hasattr(image, 'convert') and callable(image.convert):
190 |                 alpha = image.convert('RGBA').split()[3]
191 |                 background.paste(image, mask=alpha)
192 |                 image = background
193 |         
194 |         # Resize large images
195 |         max_dimension = 1200
196 |         if width > max_dimension or height > max_dimension:
197 |             if width > height:
198 |                 new_width = max_dimension
199 |                 new_height = int(height * (max_dimension / width))
200 |             else:
201 |                 new_height = max_dimension
202 |                 new_width = int(width * (max_dimension / height))
203 |             
204 |             image = image.resize((new_width, new_height), Image.LANCZOS)
205 |             width, height = image.size
206 |         
207 |         # Convert to base64
208 |         buffered = BytesIO()
209 |         image.save(buffered, format="JPEG", quality=85)
210 |         img_str = base64.b64encode(buffered.getvalue()).decode()
211 |         
212 |         return ImageInfo(
213 |             file_path=filepath,
214 |             file_name=filename,
215 |             base64_data=img_str,
216 |             width=width,
217 |             height=height
218 |         )
219 |     except Exception as e:
220 |         st.error(f"Error creating ImageInfo: {str(e)}")
221 |         return None


--------------------------------------------------------------------------------
/modules/models.py:
--------------------------------------------------------------------------------
 1 | """
 2 | Data models for the PDF to Presentation application.
 3 | """
 4 | from pydantic import BaseModel
 5 | from typing import List, Optional
 6 | 
 7 | class KeySection(BaseModel):
 8 |     """Represents a key section extracted from a document."""
 9 |     title: str
10 |     content: str
11 |     importance: int
12 |     themes: List[str]
13 |     visual_elements: List[str]
14 | 
15 | class ContentExtractionResult(BaseModel):
16 |     """Results from content extraction process."""
17 |     document_title: str
18 |     summary: str
19 |     key_sections: List[KeySection]
20 |     overall_themes: List[str]
21 | 
22 | class VisualPrompt(BaseModel):
23 |     """Prompt for image generation."""
24 |     section_title: str
25 |     prompt: str
26 |     style_guidance: str
27 |     avoid_elements: List[str]
28 |     reference_section: str
29 | 
30 | class ImageInfo(BaseModel):
31 |     """Information about a generated image."""
32 |     file_path: str
33 |     file_name: str
34 |     base64_data: str
35 |     width: int
36 |     height: int
37 | 
38 | class HTMLSlide(BaseModel):
39 |     """Represents an HTML slide."""
40 |     html_content: str
41 |     title: str
42 |     section_title: str
43 |     section_content: str
44 | 
45 | # Bosch Brand Colors
46 | BOSCH_COLORS = {
47 |     "primary": "#E20015",  # Bosch Red
48 |     "black": "#000000",
49 |     "white": "#FFFFFF",
50 |     "dark_gray": "#333333",
51 |     "medium_gray": "#7D7D7D",
52 |     "light_gray": "#E5E5E5",
53 |     "secondary_blue": "#007BC0",
54 |     "secondary_green": "#00884A"
55 | }


--------------------------------------------------------------------------------
/modules/pptx_converter.py:
--------------------------------------------------------------------------------
  1 | """
  2 | PowerPoint conversion functionality.
  3 | Convert HTML slides to PowerPoint format with styling similar to HTML slides.
  4 | """
  5 | import os
  6 | import io
  7 | import base64
  8 | import re
  9 | from pptx import Presentation
 10 | from pptx.util import Inches, Pt
 11 | from pptx.enum.text import PP_ALIGN
 12 | from pptx.dml.color import RGBColor
 13 | from PIL import Image
 14 | 
 15 | # BOSCH Colors - matching the HTML slides
 16 | BOSCH_COLORS = {
 17 |     "primary": "#E20015",  # Bosch Red
 18 |     "black": "#000000",
 19 |     "white": "#FFFFFF",
 20 |     "dark_gray": "#333333",
 21 |     "medium_gray": "#7D7D7D",
 22 |     "light_gray": "#E5E5E5",
 23 |     "secondary_blue": "#007BC0",
 24 |     "secondary_green": "#00884A"
 25 | }
 26 | 
 27 | def hex_to_rgb(hex_color):
 28 |     """
 29 |     Convert hex color to RGB.
 30 |     
 31 |     Args:
 32 |         hex_color (str): Hex color code (e.g., "#FF0000")
 33 |         
 34 |     Returns:
 35 |         tuple: (R, G, B) values
 36 |     """
 37 |     hex_color = hex_color.lstrip('#')
 38 |     return tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))
 39 | 
 40 | def create_powerpoint_from_slides(slides, extraction_result=None, output_path=None):
 41 |     """
 42 |     Create a PowerPoint presentation from HTML slides with similar styling.
 43 |     
 44 |     Args:
 45 |         slides (list): List of HTMLSlide objects
 46 |         extraction_result: Content extraction result
 47 |         output_path (str): Path to save the presentation
 48 |         
 49 |     Returns:
 50 |         BytesIO: BytesIO object containing the PowerPoint file
 51 |     """
 52 |     # Create a new presentation
 53 |     prs = Presentation()
 54 |     
 55 |     # Set slide size to 16:9 aspect ratio
 56 |     prs.slide_width = Inches(16)
 57 |     prs.slide_height = Inches(9)
 58 |     
 59 |     # Create a custom slide layout without bullet points (we'll add our own content)
 60 |     blank_slide_layout = prs.slide_layouts[6]  # Blank layout
 61 |     title_slide_layout = prs.slide_layouts[0]  # Title slide layout
 62 |     
 63 |     # Extract colors from BOSCH_COLORS
 64 |     primary_color = hex_to_rgb(BOSCH_COLORS["primary"])  # Bosch Red
 65 |     secondary_color = hex_to_rgb(BOSCH_COLORS["secondary_blue"])  # Bosch Blue
 66 |     text_color = hex_to_rgb(BOSCH_COLORS["dark_gray"])  # Dark Gray
 67 |     light_text_color = hex_to_rgb(BOSCH_COLORS["medium_gray"])  # Medium Gray
 68 |     
 69 |     # Add a title slide
 70 |     title_slide = prs.slides.add_slide(title_slide_layout)
 71 |     
 72 |     # Style the title slide
 73 |     title = title_slide.shapes.title
 74 |     title.text = extraction_result.document_title if extraction_result else "Presentation"
 75 |     
 76 |     # Style the title text on title slide
 77 |     title_text_frame = title.text_frame
 78 |     title_paragraph = title_text_frame.paragraphs[0]
 79 |     title_paragraph.alignment = PP_ALIGN.LEFT
 80 |     title_run = title_paragraph.runs[0]
 81 |     title_run.font.size = Pt(44)
 82 |     title_run.font.bold = True
 83 |     title_run.font.color.rgb = RGBColor(*text_color)
 84 |     
 85 |     # Add subtitle
 86 |     subtitle = extraction_result.summary if extraction_result else ""
 87 |     if subtitle and len(title_slide.placeholders) > 1:
 88 |         subtitle_placeholder = title_slide.placeholders[1]
 89 |         subtitle_placeholder.text = subtitle[:300] + "..." if len(subtitle) > 300 else subtitle
 90 |         
 91 |         # Style the subtitle
 92 |         for paragraph in subtitle_placeholder.text_frame.paragraphs:
 93 |             paragraph.alignment = PP_ALIGN.LEFT
 94 |             for run in paragraph.runs:
 95 |                 run.font.size = Pt(20)
 96 |                 run.font.color.rgb = RGBColor(*secondary_color)
 97 |     
 98 |     # Try to load company logo if exists
 99 |     logo_path = None
100 |     for p in [os.path.join(os.getcwd(), "logo.png"), 
101 |               os.path.join(os.getcwd(), "static", "logo.png"),
102 |               os.path.join(os.getcwd(), "assets", "logo.png")]:
103 |         if os.path.exists(p):
104 |             logo_path = p
105 |             break
106 |     
107 |     # Add logo to title slide if available
108 |     if logo_path:
109 |         logo_height = Inches(0.6)
110 |         logo_left = prs.slide_width - Inches(1.2)
111 |         logo_top = prs.slide_height - Inches(0.8)
112 |         title_slide.shapes.add_picture(logo_path, logo_left, logo_top, height=logo_height)
113 |     
114 |     # Process each slide
115 |     for slide_obj in slides:
116 |         # Create a blank slide (we'll add custom elements)
117 |         slide = prs.slides.add_slide(blank_slide_layout)
118 |         
119 |         # Add a title box at the top
120 |         title_left = Inches(0.5)
121 |         title_top = Inches(0.5)
122 |         title_width = prs.slide_width - Inches(1)
123 |         title_height = Inches(1)
124 |         
125 |         title_shape = slide.shapes.add_textbox(title_left, title_top, title_width, title_height)
126 |         title_frame = title_shape.text_frame
127 |         title_paragraph = title_frame.add_paragraph()
128 |         title_paragraph.text = slide_obj.title
129 |         title_paragraph.alignment = PP_ALIGN.LEFT
130 |         
131 |         # Style the title
132 |         title_run = title_paragraph.runs[0]
133 |         title_run.font.size = Pt(36)
134 |         title_run.font.bold = True
135 |         title_run.font.color.rgb = RGBColor(*text_color)
136 |         
137 |         # Add subtitle with document title
138 |         subtitle_paragraph = title_frame.add_paragraph()
139 |         subtitle_paragraph.text = extraction_result.document_title if extraction_result else ""
140 |         subtitle_paragraph.alignment = PP_ALIGN.LEFT
141 |         
142 |         # Style the subtitle
143 |         subtitle_run = subtitle_paragraph.runs[0]
144 |         subtitle_run.font.size = Pt(20)
145 |         subtitle_run.font.color.rgb = RGBColor(*secondary_color)
146 |         
147 |         # Process bullet points from section_content
148 |         bullet_points = []
149 |         if slide_obj.section_content and "," in slide_obj.section_content:
150 |             bullet_points = slide_obj.section_content.split(", ")
151 |         else:
152 |             # If no comma-separated content, try to extract bullet points from HTML
153 |             bullet_pattern = r'<div class="bullet-text">([^<]+)</div>'
154 |             bullet_matches = re.findall(bullet_pattern, slide_obj.html_content)
155 |             if bullet_matches:
156 |                 bullet_points = bullet_matches
157 |         
158 |         # Filter out empty bullet points
159 |         bullet_points = [p for p in bullet_points if p and len(p.strip()) > 0]
160 |         
161 |         # Determine layout based on content - similar to the HTML slide logic
162 |         # If few bullet points -> image focus, if many -> text focus
163 |         is_image_focus = len(bullet_points) <= 2 and "image" in slide_obj.title.lower()
164 |         is_text_focus = len(bullet_points) >= 5
165 |         
166 |         # Extract base64 image from the slide
167 |         base64_image_pattern = r'src="data:image\/jpeg;base64,([^"]+)"'
168 |         match = re.search(base64_image_pattern, slide_obj.html_content)
169 |         image_data = None
170 |         
171 |         if match:
172 |             # Extract base64 image data
173 |             base64_data = match.group(1)
174 |             image_data = base64.b64decode(base64_data)
175 |         
176 |         # Position content based on layout
177 |         if is_image_focus:
178 |             # Image focus layout - large image on top, bullets below
179 |             if image_data:
180 |                 image_stream = io.BytesIO(image_data)
181 |                 image_width = Inches(10)
182 |                 image_left = (prs.slide_width - image_width) / 2  # Center
183 |                 image_top = Inches(1.8)
184 |                 slide.shapes.add_picture(image_stream, image_left, image_top, width=image_width)
185 |             
186 |             # Add bullet points below the image
187 |             bullet_box_left = Inches(1)
188 |             bullet_box_top = Inches(5.5)
189 |             bullet_box_width = prs.slide_width - Inches(2)
190 |             bullet_box_height = Inches(2.5)
191 |             
192 |             if bullet_points:
193 |                 bullet_box = slide.shapes.add_textbox(bullet_box_left, bullet_box_top, bullet_box_width, bullet_box_height)
194 |                 
195 |                 # Create styled bullet points
196 |                 bullet_frame = bullet_box.text_frame
197 |                 for i, point in enumerate(bullet_points):
198 |                     p = bullet_frame.add_paragraph()
199 |                     p.text = point
200 |                     p.level = 0
201 |                     
202 |                     # Style the bullet point
203 |                     run = p.runs[0]
204 |                     run.font.size = Pt(20)
205 |                     run.font.color.rgb = RGBColor(*text_color)
206 |         else:
207 |             # Standard layout - bullets on left, image on right
208 |             # Or text focus - more space for text
209 |             
210 |             # Calculate sizes based on layout
211 |             if is_text_focus:
212 |                 # Text focus - bullets get more space
213 |                 bullet_box_width = prs.slide_width * 0.7
214 |                 image_width = prs.slide_width * 0.25
215 |             else:
216 |                 # Balanced layout
217 |                 bullet_box_width = prs.slide_width * 0.55
218 |                 image_width = prs.slide_width * 0.35
219 |             
220 |             # Add bullet points on the left
221 |             bullet_box_left = Inches(0.5)
222 |             bullet_box_top = Inches(2)
223 |             bullet_box_height = prs.slide_height - Inches(3)
224 |             
225 |             if bullet_points:
226 |                 bullet_box = slide.shapes.add_textbox(bullet_box_left, bullet_box_top, bullet_box_width, bullet_box_height)
227 |                 
228 |                 # Create a styled container to match HTML slide look
229 |                 bullet_frame = bullet_box.text_frame
230 |                 
231 |                 for i, point in enumerate(bullet_points):
232 |                     p = bullet_frame.add_paragraph()
233 |                     
234 |                     # Add bullet character (similar to HTML)
235 |                     p.text = f"â€¢ {point}"
236 |                     p.level = 0
237 |                     
238 |                     # Style the bullet point
239 |                     run = p.runs[0]
240 |                     run.font.size = Pt(18)
241 |                     run.font.color.rgb = RGBColor(*text_color)
242 |                     
243 |                     # Add space between bullet points
244 |                     if i < len(bullet_points) - 1:
245 |                         p.space_after = Pt(12)
246 |             
247 |             # Add image on the right if available
248 |             if image_data:
249 |                 image_stream = io.BytesIO(image_data)
250 |                 image_left = prs.slide_width - image_width - Inches(0.5)
251 |                 image_top = Inches(2)
252 |                 slide.shapes.add_picture(image_stream, image_left, image_top, width=image_width)
253 |         
254 |         # Add footer with document title and slide title
255 |         footer_top = prs.slide_height - Inches(0.5)
256 |         footer_left = Inches(0.5)
257 |         footer_width = prs.slide_width - Inches(2)
258 |         footer_height = Inches(0.4)
259 |         
260 |         footer_shape = slide.shapes.add_textbox(footer_left, footer_top, footer_width, footer_height)
261 |         footer_frame = footer_shape.text_frame
262 |         footer_paragraph = footer_frame.add_paragraph()
263 |         footer_paragraph.text = f"{extraction_result.document_title if extraction_result else 'Presentation'} | {slide_obj.title}"
264 |         footer_paragraph.alignment = PP_ALIGN.LEFT
265 |         
266 |         # Style the footer
267 |         footer_run = footer_paragraph.runs[0]
268 |         footer_run.font.size = Pt(10)
269 |         footer_run.font.color.rgb = RGBColor(*light_text_color)
270 |         
271 |         # Add company logo if available
272 |         if logo_path:
273 |             logo_height = Inches(0.5)
274 |             logo_left = prs.slide_width - Inches(1.2)
275 |             logo_top = prs.slide_height - Inches(0.8)
276 |             slide.shapes.add_picture(logo_path, logo_left, logo_top, height=logo_height)
277 |     
278 |     # Save the presentation
279 |     output = io.BytesIO()
280 |     prs.save(output)
281 |     output.seek(0)
282 |     
283 |     # Also save to file if path is provided
284 |     if output_path:
285 |         prs.save(output_path)
286 |     
287 |     return output


--------------------------------------------------------------------------------
/modules/processor.py:
--------------------------------------------------------------------------------
  1 | """
  2 | Main processing logic for PDF to presentation conversion.
  3 | """
  4 | import os
  5 | import asyncio
  6 | import streamlit as st
  7 | 
  8 | from modules.helpers import extract_text_from_pdf, generate_image_from_prompt, save_image_locally, load_image_info_from_pil
  9 | from modules.agents import extract_key_sections, create_visual_prompt
 10 | from modules.slide_generator import create_html_slide
 11 | from utils.openai_client import initialize_openai
 12 | 
 13 | async def process_pdf_to_presentation(pdf_file):
 14 |     """
 15 |     Complete PDF to presentation process.
 16 |     
 17 |     Args:
 18 |         pdf_file: Uploaded PDF file
 19 |         
 20 |     Returns:
 21 |         dict: Processing results or None if processing failed
 22 |     """
 23 |     # Reset session state
 24 |     st.session_state.pdf_content = None
 25 |     st.session_state.key_sections = None
 26 |     st.session_state.image_prompts = []
 27 |     st.session_state.generated_images = []
 28 |     st.session_state.slides_html = []
 29 |     st.session_state.process_complete = False
 30 |     
 31 |     # Create progress indicators
 32 |     progress_bar = st.progress(0)
 33 |     
 34 |     # Display status indicators
 35 |     step1_status = st.empty()
 36 |     step2_status = st.empty()
 37 |     step3_status = st.empty()
 38 |     step4_status = st.empty()
 39 |     
 40 |     # Initialize clients
 41 |     _, dalle_client = initialize_openai()
 42 |     
 43 |     try:
 44 |         # Step 1: Extract PDF content
 45 |         step1_status.markdown('<div class="step-item status-processing">Extracting content from PDF...</div>', unsafe_allow_html=True)
 46 |         
 47 |         pdf_text = extract_text_from_pdf(pdf_file)
 48 |         if not pdf_text:
 49 |             step1_status.markdown('<div class="step-item status-error">Failed to extract PDF content</div>', unsafe_allow_html=True)
 50 |             return None
 51 |         
 52 |         progress_bar.progress(10)
 53 |         st.session_state.pdf_content = pdf_text[:500] + "..." if len(pdf_text) > 500 else pdf_text
 54 |         
 55 |         # Extract key sections
 56 |         extraction_result = await extract_key_sections(pdf_text)
 57 |         st.session_state.key_sections = extraction_result
 58 |         
 59 |         step1_status.markdown('<div class="step-item status-complete">âœ… PDF Content Extracted</div>', unsafe_allow_html=True)
 60 |         
 61 |         # Step 2: Create image prompts
 62 |         step2_status.markdown('<div class="step-item status-processing">Creating image prompts...</div>', unsafe_allow_html=True)
 63 |         
 64 |         # Generate prompts for each section
 65 |         prompts = []
 66 |         for i, section in enumerate(extraction_result.key_sections):
 67 |             progress_bar.progress(10 + (20 * (i+1) // len(extraction_result.key_sections)))
 68 |             prompt = await create_visual_prompt(section, extraction_result.document_title)
 69 |             prompts.append(prompt)
 70 |         
 71 |         st.session_state.image_prompts = prompts
 72 |         progress_bar.progress(30)
 73 |         
 74 |         step2_status.markdown('<div class="step-item status-complete">âœ… Image Prompts Created</div>', unsafe_allow_html=True)
 75 |         
 76 |         # Step 3: Generate images
 77 |         step3_status.markdown('<div class="step-item status-processing">Generating images...</div>', unsafe_allow_html=True)
 78 |         
 79 |         # Generate images
 80 |         images = []
 81 |         image_infos = []
 82 |         os.makedirs(st.session_state.images_folder, exist_ok=True)
 83 |         
 84 |         # Process images in parallel to speed things up
 85 |         async def process_image(prompt, index):
 86 |             try:
 87 |                 # Generate image
 88 |                 image_result = generate_image_from_prompt(dalle_client, prompt.prompt)
 89 |                 
 90 |                 if image_result and "image" in image_result:
 91 |                     # Save image
 92 |                     is_placeholder = image_result.get("is_placeholder", False)
 93 |                     filename_prefix = "placeholder_" if is_placeholder else ""
 94 |                     
 95 |                     save_result = save_image_locally(
 96 |                         image_result["image"], 
 97 |                         f"{filename_prefix}{prompt.section_title}", 
 98 |                         index+1,
 99 |                         st.session_state.images_folder
100 |                     )
101 |                     
102 |                     if save_result["success"]:
103 |                         # Create image info
104 |                         image_info = load_image_info_from_pil(
105 |                             image_result["image"],
106 |                             os.path.basename(save_result["filepath"]),
107 |                             save_result["filepath"]
108 |                         )
109 |                         
110 |                         if image_info:
111 |                             return {
112 |                                 "index": index,
113 |                                 "image_result": image_result,
114 |                                 "save_result": save_result,
115 |                                 "image_info": image_info
116 |                             }
117 |             except Exception as e:
118 |                 st.warning(f"Error processing image {index+1}: {str(e)}")
119 |             
120 |             return None
121 |         
122 |         # Create tasks for parallel processing
123 |         tasks = [process_image(prompt, i) for i, prompt in enumerate(prompts)]
124 |         results = await asyncio.gather(*tasks)
125 |         
126 |         # Process results and update progress
127 |         valid_results = [r for r in results if r is not None]
128 |         for result in sorted(valid_results, key=lambda x: x["index"]):
129 |             images.append({
130 |                 **result["image_result"],
131 |                 "save_result": result["save_result"],
132 |                 "image_info": result["image_info"]
133 |             })
134 |             image_infos.append(result["image_info"])
135 |             
136 |             # Update progress
137 |             progress_updated = 30 + (30 * (len(images)) // len(prompts))
138 |             progress_bar.progress(min(60, progress_updated))
139 |         
140 |         # Store images
141 |         st.session_state.generated_images = images
142 |         
143 |         # Check if we have enough images
144 |         if len(image_infos) < len(extraction_result.key_sections):
145 |             step3_status.markdown('<div class="step-item status-error">âš ï¸ Some images failed to generate</div>', unsafe_allow_html=True)
146 |         else:
147 |             step3_status.markdown('<div class="step-item status-complete">âœ… Images Generated</div>', unsafe_allow_html=True)
148 |         
149 |         progress_bar.progress(60)
150 |         
151 |         # Step 4: Create HTML slides
152 |         step4_status.markdown('<div class="step-item status-processing">Creating HTML slides...</div>', unsafe_allow_html=True)
153 |         
154 |         # Process slides in parallel
155 |         async def process_slide(section, image_info, index):
156 |             try:
157 |                 slide = await create_html_slide(section, image_info, extraction_result.document_title)
158 |                 return {
159 |                     "index": index,
160 |                     "slide": slide
161 |                 }
162 |             except Exception as e:
163 |                 st.warning(f"Error creating slide {index+1}: {str(e)}")
164 |                 return None
165 |         
166 |         # Create tasks for parallel processing (up to limit of valid images)
167 |         max_slides = min(len(extraction_result.key_sections), len(image_infos))
168 |         slide_tasks = [
169 |             process_slide(extraction_result.key_sections[i], image_infos[i], i)
170 |             for i in range(max_slides)
171 |         ]
172 |         
173 |         slide_results = await asyncio.gather(*slide_tasks)
174 |         
175 |         # Process results
176 |         slides = []
177 |         valid_slide_results = [r for r in slide_results if r is not None]
178 |         for result in sorted(valid_slide_results, key=lambda x: x["index"]):
179 |             slides.append(result["slide"])
180 |             
181 |             # Update progress
182 |             progress_updated = 60 + (40 * (len(slides)) // max_slides)
183 |             progress_bar.progress(min(100, progress_updated))
184 |         
185 |         # Store slides
186 |         st.session_state.slides_html = slides
187 |         
188 |         # Complete
189 |         progress_bar.progress(100)
190 |         
191 |         if len(slides) > 0:
192 |             step4_status.markdown('<div class="step-item status-complete">âœ… HTML Slides Created</div>', unsafe_allow_html=True)
193 |             st.session_state.process_complete = True
194 |             return {
195 |                 "extraction_result": extraction_result,
196 |                 "prompts": prompts,
197 |                 "images": images,
198 |                 "slides": slides
199 |             }
200 |         else:
201 |             step4_status.markdown('<div class="step-item status-error">âŒ Slide Creation Failed</div>', unsafe_allow_html=True)
202 |             return None
203 |         
204 |     except Exception as e:
205 |         import traceback
206 |         error_details = traceback.format_exc()
207 |         st.error(f"Error: {str(e)}")
208 |         return None


--------------------------------------------------------------------------------
/modules/slide_generator.py:
--------------------------------------------------------------------------------
  1 | """
  2 | HTML slide generation functionality.
  3 | """
  4 | import os
  5 | import base64
  6 | from modules.models import HTMLSlide, BOSCH_COLORS
  7 | from modules.agents import extract_key_bullet_points
  8 | 
  9 | def load_company_logo():
 10 |     """
 11 |     Load company logo and convert to base64.
 12 |     
 13 |     Returns:
 14 |         str: Base64 encoded logo
 15 |     """
 16 |     try:
 17 |         # Look for logo.png in the current directory
 18 |         logo_path = os.path.join(os.getcwd(), "logo.png")
 19 |         
 20 |         # If not found there, check other common locations
 21 |         if not os.path.exists(logo_path):
 22 |             # Check static folder if it exists
 23 |             static_path = os.path.join(os.getcwd(), "static", "logo.png")
 24 |             if os.path.exists(static_path):
 25 |                 logo_path = static_path
 26 |             else:
 27 |                 # Check assets folder if it exists
 28 |                 assets_path = os.path.join(os.getcwd(), "assets", "logo.png")
 29 |                 if os.path.exists(assets_path):
 30 |                     logo_path = assets_path
 31 |         
 32 |         # If logo is found, encode it
 33 |         if os.path.exists(logo_path):
 34 |             with open(logo_path, "rb") as image_file:
 35 |                 encoded_string = base64.b64encode(image_file.read()).decode()
 36 |                 return encoded_string
 37 |     except Exception as e:
 38 |         print(f"Error loading logo: {e}")
 39 |     
 40 |     # Return a transparent placeholder if logo not found or error occurs
 41 |     return "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII="
 42 | 
 43 | async def create_html_slide(section, image_info, document_title):
 44 |     """
 45 |     Create a professional HTML slide with various layouts based on content type.
 46 |     
 47 |     Args:
 48 |         section: Section to create slide for
 49 |         image_info: Image information
 50 |         document_title (str): Document title
 51 |         
 52 |     Returns:
 53 |         HTMLSlide: Generated HTML slide
 54 |     """
 55 |     # Get concise bullet points using dedicated agent
 56 |     bullet_points = await extract_key_bullet_points(section, document_title)
 57 |     
 58 |     # Generate a clean title for the slide
 59 |     slide_title = section.title.strip()
 60 |     
 61 |     # Define Bosch color scheme
 62 |     subtitle_color = "#007BC0"  # Bosch blue
 63 |     colors = {
 64 |         "primary": "#E20015",  # Bosch Red
 65 |         "secondary": "#007BC0", # Bosch Blue
 66 |         "accent": "#00884A",    # Bosch Green
 67 |         "text": "#333333",      # Dark Gray
 68 |         "light_text": "#7D7D7D", # Medium Gray
 69 |         "background": "#FFFFFF", # White
 70 |         "slide_bg": "#FFFFFF",   # White
 71 |         "card_bg": "#F5F5F5"     # Light Gray
 72 |     }
 73 |     
 74 |     # DETERMINE LAYOUT TYPE based on content analysis
 75 |     # 1. Count bullet points
 76 |     num_bullet_points = len(bullet_points)
 77 |     
 78 |     # 2. Analyze section title for keywords
 79 |     title_lower = slide_title.lower()
 80 |     image_keywords = ["visual", "diagram", "chart", "picture", "image", "photo"]
 81 |     has_image_keywords = any(keyword in title_lower for keyword in image_keywords)
 82 |     
 83 |     # 3. Determine section content length
 84 |     content_length = len(section.content)
 85 |     
 86 |     # 4. Choose appropriate layout
 87 |     if num_bullet_points <= 2 and has_image_keywords:
 88 |         # Use a centered large image layout
 89 |         layout_type = "image_focus"
 90 |     elif num_bullet_points >= 5:
 91 |         # Use a text-heavy layout
 92 |         layout_type = "text_focus"
 93 |     elif "comparison" in title_lower or "versus" in title_lower or "vs" in title_lower:
 94 |         # Use a split comparison layout
 95 |         layout_type = "comparison"
 96 |     elif content_length > 500:
 97 |         # Use a text-heavy layout for longer content
 98 |         layout_type = "text_focus"
 99 |     else:
100 |         # Use a balanced layout
101 |         layout_type = "balanced"
102 |     
103 |     # Generate bullet points HTML
104 |     bullet_points_html = generate_bullet_points_html(bullet_points, layout_type, colors)
105 |     
106 |     # Create a professional HTML slide template based on layout
107 |     html_content = generate_html_content(
108 |         slide_title, document_title, layout_type, bullet_points_html, image_info, colors, subtitle_color
109 |     )
110 |     
111 |     # Create a valid HTMLSlide object
112 |     html_slide = HTMLSlide(
113 |         html_content=html_content,
114 |         title=slide_title,
115 |         section_title=section.title,
116 |         section_content=", ".join(bullet_points) if bullet_points else section.content[:100] + "..."
117 |     )
118 |     
119 |     return html_slide
120 | 
121 | def generate_bullet_points_html(bullet_points, layout_type, colors):
122 |     """
123 |     Generate HTML for bullet points based on layout type.
124 |     
125 |     Args:
126 |         bullet_points (list): List of bullet points
127 |         layout_type (str): Layout type
128 |         colors (dict): Color scheme
129 |         
130 |     Returns:
131 |         str: HTML for bullet points
132 |     """
133 |     bullet_points_html = ""
134 |     
135 |     # Different styling for bullet points based on layout
136 |     if layout_type == "text_focus":
137 |         # Compact bullet points
138 |         for i, point in enumerate(bullet_points):
139 |             bullet_points_html += f"""
140 |             <div class="bullet-point compact" style="animation-delay: {i * 0.15}s;">
141 |                 <div class="bullet-icon">â€¢</div>
142 |                 <div class="bullet-text">{point}</div>
143 |             </div>
144 |             """
145 |     elif layout_type == "comparison":
146 |         # Split into two columns if possible
147 |         half = len(bullet_points) // 2
148 |         bullet_points_html += '<div class="comparison-container">'
149 |         
150 |         bullet_points_html += '<div class="comparison-column">'
151 |         for i, point in enumerate(bullet_points[:half]):
152 |             bullet_points_html += f"""
153 |             <div class="bullet-point comparison-item" style="animation-delay: {i * 0.15}s;">
154 |                 <div class="bullet-text">{point}</div>
155 |             </div>
156 |             """
157 |         bullet_points_html += '</div>'
158 |         
159 |         bullet_points_html += '<div class="comparison-column">'
160 |         for i, point in enumerate(bullet_points[half:]):
161 |             bullet_points_html += f"""
162 |             <div class="bullet-point comparison-item" style="animation-delay: {(i+half) * 0.15}s;">
163 |                 <div class="bullet-text">{point}</div>
164 |             </div>
165 |             """
166 |         bullet_points_html += '</div>'
167 |         bullet_points_html += '</div>'
168 |     elif layout_type == "image_focus":
169 |         # More descriptive bullet points for image-focused layouts
170 |         for i, point in enumerate(bullet_points):
171 |             bullet_points_html += f"""
172 |             <div class="bullet-point highlight" style="animation-delay: {i * 0.15}s;">
173 |                 <div class="bullet-number">{i+1}</div>
174 |                 <div class="bullet-text">{point}</div>
175 |             </div>
176 |             """
177 |     else:
178 |         # Standard bullet points
179 |         for i, point in enumerate(bullet_points):
180 |             bullet_points_html += f"""
181 |             <div class="bullet-point" style="animation-delay: {i * 0.15}s;">
182 |                 <div class="bullet-icon">
183 |                     <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
184 |                         <path d="M12 2C6.48 2 2 6.48 2 12C2 17.52 6.48 22 12 22C17.52 22 22 17.52 22 12C22 6.48 17.52 2 12 2ZM10 17L5 12L6.41 10.59L10 14.17L17.59 6.58L19 8L10 17Z" fill="{colors["secondary"]}"/>
185 |                     </svg>
186 |                 </div>
187 |                 <div class="bullet-text">{point}</div>
188 |             </div>
189 |             """
190 |     return bullet_points_html
191 | 
192 | def generate_html_content(slide_title, document_title, layout_type, bullet_points_html, image_info, colors, subtitle_color):
193 |     """
194 |     Generate HTML content for a slide.
195 |     
196 |     Args:
197 |         slide_title (str): Slide title
198 |         document_title (str): Document title
199 |         layout_type (str): Layout type
200 |         bullet_points_html (str): HTML for bullet points
201 |         image_info: Image information
202 |         colors (dict): Color scheme
203 |         subtitle_color (str): Subtitle color
204 |         
205 |     Returns:
206 |         str: HTML content for the slide
207 |     """
208 |     # Create a professional HTML slide template based on layout
209 |     html_content = f"""<!DOCTYPE html>
210 | <html lang="en">
211 | <head>
212 |     <meta charset="UTF-8">
213 |     <meta name="viewport" content="width=device-width, initial-scale=1.0">
214 |     <title>{slide_title} - {document_title}</title>
215 |     <style>
216 |         /* Reset and base styles */
217 |         * {{
218 |             margin: 0;
219 |             padding: 0;
220 |             box-sizing: border-box;
221 |         }}
222 |         
223 |         @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap');
224 |         
225 |         body {{
226 |             font-family: 'Poppins', 'Segoe UI', Roboto, Arial, sans-serif;
227 |             color: {colors["text"]};
228 |             background-color: {colors["slide_bg"]};
229 |             line-height: 1.6;
230 |             display: flex;
231 |             justify-content: center;
232 |             align-items: center;
233 |             min-height: 100vh;
234 |             padding: 20px;
235 |         }}
236 |         
237 |         /* Slide container */
238 |         .slide {{
239 |             width: 1280px;
240 |             height: 720px;
241 |             background-color: {colors["background"]};
242 |             box-shadow: 0 10px 40px rgba(0, 0, 0, 0.1);
243 |             border-radius: 12px;
244 |             overflow: hidden;
245 |             position: relative;
246 |             display: grid;
247 |             grid-template-rows: auto 1fr auto;
248 |         }}
249 |         
250 |         /* Header */
251 |         .header {{
252 |             padding: 20px 50px 10px;
253 |             position: relative;
254 |             z-index: 1;
255 |         }}
256 |         
257 |         .title {{
258 |             font-size: 32px;
259 |             font-weight: 700;
260 |             color: {colors["text"]};
261 |             letter-spacing: -0.5px;
262 |             display: block;
263 |         }}
264 |         
265 |         .subtitle {{
266 |             font-size: 22px;
267 |             font-weight: 500;
268 |             color: {subtitle_color};
269 |             margin-top: 5px;
270 |         }}
271 |         
272 |         /* Common content styles */
273 |         .content {{
274 |             position: relative;
275 |             z-index: 1;
276 |             padding: 30px 50px;
277 |         }}
278 |         
279 |         /* Layout specific styles */
280 |         /* 1. BALANCED LAYOUT - Standard split */
281 |         {".content { display: grid; grid-template-columns: 3fr 2fr; gap: 30px; }" if layout_type == "balanced" else ""}
282 |         
283 |         /* 2. TEXT FOCUS LAYOUT - More space for text */
284 |         {".content { display: grid; grid-template-columns: 4fr 1fr; gap: 30px; }" if layout_type == "text_focus" else ""}
285 |         
286 |         /* 3. IMAGE FOCUS LAYOUT - Image prominent */
287 |         {".content { display: flex; flex-direction: column; } .image-container { margin-bottom: 30px; width: 100%; max-height: 450px; } .bullet-points { display: flex; flex-direction: row; justify-content: space-between; }" if layout_type == "image_focus" else ""}
288 |         
289 |         /* 4. COMPARISON LAYOUT - Side by side */
290 |         {".content { display: block; } .comparison-container { display: flex; gap: 50px; } .comparison-column { flex: 1; }" if layout_type == "comparison" else ""}
291 |         
292 |         /* Text column */
293 |         .text-column {{
294 |             display: flex;
295 |             flex-direction: column;
296 |         }}
297 |         
298 |         /* Bullet points */
299 |         .bullet-points {{
300 |             display: flex;
301 |             flex-direction: column;
302 |             gap: 18px;
303 |             margin-top: 10px;
304 |         }}
305 |         
306 |         .bullet-point {{
307 |             display: flex;
308 |             align-items: flex-start;
309 |             background-color: {colors["card_bg"]};
310 |             border-radius: 10px;
311 |             padding: 16px 20px;
312 |             box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
313 |             transform: translateY(20px);
314 |             opacity: 0;
315 |             animation: slide-in 0.5s forwards ease-out;
316 |             transition: all 0.3s ease;
317 |         }}
318 |         
319 |         /* Add styles for different bullet point types */
320 |         .bullet-point.compact {{
321 |             padding: 10px 15px;
322 |         }}
323 |         
324 |         .bullet-point.highlight {{
325 |             background: linear-gradient(135deg, {colors["secondary"]}10, {colors["background"]});
326 |             border-left: 4px solid {colors["secondary"]};
327 |         }}
328 |         
329 |         .bullet-point.comparison-item {{
330 |             text-align: center;
331 |             justify-content: center;
332 |         }}
333 |         
334 |         .bullet-icon {{
335 |             margin-right: 15px;
336 |             flex-shrink: 0;
337 |             margin-top: 2px;
338 |         }}
339 |         
340 |         .bullet-number {{
341 |             width: 26px;
342 |             height: 26px;
343 |             border-radius: 50%;
344 |             background-color: {colors["secondary"]};
345 |             color: white;
346 |             display: flex;
347 |             align-items: center;
348 |             justify-content: center;
349 |             font-weight: bold;
350 |             margin-right: 15px;
351 |             flex-shrink: 0;
352 |         }}
353 |         
354 |         .bullet-text {{
355 |             font-size: 18px;
356 |             font-weight: 500;
357 |             color: {colors["text"]};
358 |             line-height: 1.4;
359 |         }}
360 |         
361 |         /* Image column */
362 |         .image-column {{
363 |             display: flex;
364 |             align-items: center;
365 |             justify-content: center;
366 |         }}
367 |         
368 |         .image-container {{
369 |             width: 100%;
370 |             max-width: 450px;
371 |             height: auto;
372 |             max-height: 400px;
373 |             display: flex;
374 |             align-items: center;
375 |             justify-content: center;
376 |             position: relative;
377 |             overflow: hidden;
378 |             border-radius: 12px;
379 |             box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
380 |             margin: 0 auto;
381 |         }}
382 |         
383 |         .image-container img {{
384 |             max-width: 100%;
385 |             max-height: 100%;
386 |             object-fit: contain;
387 |             border-radius: 8px;
388 |             transition: transform 0.3s ease;
389 |         }}
390 |         
391 |         @keyframes slide-in {{
392 |             to {{
393 |                 transform: translateY(0);
394 |                 opacity: 1;
395 |             }}
396 |         }}
397 |         
398 |         /* Footer */
399 |         .footer {{
400 |             padding: 15px 50px;
401 |             text-align: right;
402 |             color: {colors["light_text"]};
403 |             font-size: 14px;
404 |             font-weight: 300;
405 |             border-top: 1px solid rgba(0, 0, 0, 0.05);
406 |             position: relative;
407 |             z-index: 1;
408 |             display: flex;
409 |             justify-content: space-between;
410 |             align-items: center;
411 |         }}
412 |         
413 |         .footer-text {{
414 |             flex-grow: 1;
415 |         }}
416 |         
417 |         .company-logo {{
418 |             height: 40px;
419 |             width: auto;
420 |             margin-left: 20px;
421 |         }}
422 |     </style>
423 | </head>
424 | <body>
425 |     <div class="slide">
426 |         <div class="header">
427 |             <h1 class="title">{slide_title}</h1>
428 |             <p class="subtitle">{document_title}</p>
429 |         </div>
430 |         
431 |         <div class="content">
432 |             {f'''
433 |             <!-- IMAGE FOCUS LAYOUT -->
434 |             <div class="image-container centered-image">
435 |                 <img src="data:image/jpeg;base64,{image_info.base64_data}" alt="{slide_title}">
436 |             </div>
437 |             <div class="bullet-points">
438 |                 {bullet_points_html}
439 |             </div>
440 |             ''' if layout_type == "image_focus" else f'''
441 |             <!-- COMPARISON LAYOUT -->
442 |             {bullet_points_html}
443 |             ''' if layout_type == "comparison" else f'''
444 |             <!-- BALANCED OR TEXT FOCUSED LAYOUT -->
445 |             <div class="text-column">
446 |                 <div class="bullet-points">
447 |                     {bullet_points_html}
448 |                 </div>
449 |             </div>
450 |             <div class="image-column">
451 |                 <div class="image-container">
452 |                     <img src="data:image/jpeg;base64,{image_info.base64_data}" alt="{slide_title}">
453 |                 </div>
454 |             </div>
455 |             '''}
456 |         </div>
457 |         
458 |         <div class="footer">
459 |             <span class="footer-text">{document_title} | {slide_title}</span>
460 |             <img src="data:image/png;base64,{load_company_logo()}" alt="Company Logo" class="company-logo">
461 |         </div>
462 |     </div>
463 | </body>
464 | </html>"""
465 |     
466 |     return html_content


--------------------------------------------------------------------------------
/modules/template_pptx_converter.py:
--------------------------------------------------------------------------------
  1 | """
  2 | PowerPoint conversion functionality using organization template.
  3 | Converts content to PowerPoint slides using a corporate template.
  4 | """
  5 | import os
  6 | import io
  7 | import base64
  8 | import re
  9 | from pptx import Presentation
 10 | from pptx.util import Inches, Pt
 11 | from pptx.enum.text import PP_ALIGN
 12 | from pptx.dml.color import RGBColor
 13 | from PIL import Image
 14 | 
 15 | def create_powerpoint_from_template(slides, extraction_result=None, template_path=None, output_path=None, template_stream=None, template_file=None):
 16 |     """
 17 |     Create a PowerPoint presentation from slides using organization template.
 18 |     
 19 |     Args:
 20 |         slides (list): List of HTMLSlide objects
 21 |         extraction_result: Content extraction result
 22 |         template_path (str): Path to the template PPTX file
 23 |         output_path (str): Path to save the presentation
 24 |         template_stream (BytesIO): BytesIO stream containing the template PPTX
 25 |         template_file (str): Alternative name for template_path
 26 |         
 27 |     Returns:
 28 |         BytesIO: BytesIO object containing the PowerPoint file
 29 |     """
 30 |     # Handle template_file parameter (alias for template_path)
 31 |     if template_file and not template_path:
 32 |         template_path = template_file
 33 |         
 34 |     # Check if template exists - either as a file or stream
 35 |     if template_stream:
 36 |         # Use the provided BytesIO stream
 37 |         prs = Presentation(template_stream)
 38 |     elif template_path and os.path.exists(template_path):
 39 |         # Load from file path
 40 |         prs = Presentation(template_path)
 41 |     else:
 42 |         raise FileNotFoundError(f"Template file not found: {template_path}")
 43 |     
 44 |     # Store the original slides from the template for reference
 45 |     template_slides = [slide for slide in prs.slides]
 46 |     
 47 |     # Clean the presentation - remove all but the first slide (usually the title slide)
 48 |     # We'll keep only the first slide as title and use it as a template
 49 |     while len(prs.slides) > 1:
 50 |         r_id = prs.slides._sldIdLst[-1].rId
 51 |         prs.part.drop_rel(r_id)
 52 |         prs.slides._sldIdLst.remove(prs.slides._sldIdLst[-1])
 53 |     
 54 |     # Add the title to the first slide (simplified - just the title with no subtitle)
 55 |     if len(prs.slides) > 0:
 56 |         title_slide = prs.slides[0]
 57 |         
 58 |         # Find title placeholder
 59 |         title_placeholder = None
 60 |         subtitle_placeholder = None
 61 |         
 62 |         for shape in title_slide.shapes:
 63 |             if hasattr(shape, 'placeholder_format') and shape.placeholder_format.type == 1:  # Title
 64 |                 title_placeholder = shape
 65 |             elif hasattr(shape, 'placeholder_format') and shape.placeholder_format.type == 2:  # Subtitle
 66 |                 subtitle_placeholder = shape
 67 |         
 68 |         # Add title if found
 69 |         if title_placeholder and hasattr(title_placeholder, 'text_frame'):
 70 |             if extraction_result and hasattr(extraction_result, 'document_title'):
 71 |                 title_placeholder.text_frame.text = extraction_result.document_title
 72 |             else:
 73 |                 title_placeholder.text_frame.text = "Presentation"
 74 |         
 75 |         # Clear subtitle if found (or add minimal subtitle if needed)
 76 |         if subtitle_placeholder and hasattr(subtitle_placeholder, 'text_frame'):
 77 |             subtitle_placeholder.text_frame.text = ""  # Leave subtitle empty as requested
 78 |     
 79 |     # Find content slide templates in the original template
 80 |     content_layout = None
 81 |     
 82 |     # Look for a content layout with title and content placeholders
 83 |     for slide_layout in prs.slide_layouts:
 84 |         has_title = False
 85 |         has_content = False
 86 |         
 87 |         for placeholder in slide_layout.placeholders:
 88 |             if placeholder.placeholder_format.type == 1:  # Title
 89 |                 has_title = True
 90 |             if placeholder.placeholder_format.type == 7:  # Content
 91 |                 has_content = True
 92 |         
 93 |         if has_title and has_content:
 94 |             content_layout = slide_layout
 95 |             break
 96 |     
 97 |     # If no suitable layout found, use the first layout after title slide
 98 |     if not content_layout and len(prs.slide_layouts) > 1:
 99 |         content_layout = prs.slide_layouts[1]
100 |     
101 |     # If still no layout, use blank layout
102 |     if not content_layout:
103 |         content_layout = prs.slide_layouts[6]  # Usually blank layout
104 |     
105 |     # Try to load company logo if exists (for blank layouts where we need to add manually)
106 |     logo_path = None
107 |     for p in [os.path.join(os.getcwd(), "logo.png"), 
108 |               os.path.join(os.getcwd(), "static", "logo.png"),
109 |               os.path.join(os.getcwd(), "assets", "logo.png")]:
110 |         if os.path.exists(p):
111 |             logo_path = p
112 |             break
113 |     
114 |     # Process each slide
115 |     for slide_obj in slides:
116 |         # Create a new slide using the template layout
117 |         slide = prs.slides.add_slide(content_layout)
118 |         
119 |         # Find title and content placeholders
120 |         title_shape = None
121 |         content_shape = None
122 |         image_placeholder = None
123 |         
124 |         for shape in slide.placeholders:
125 |             if hasattr(shape, 'placeholder_format'):
126 |                 # Common placeholder types:
127 |                 # 1: Title
128 |                 # 7: Content
129 |                 # 18: Picture
130 |                 if shape.placeholder_format.type == 1:  # Title
131 |                     title_shape = shape
132 |                 elif shape.placeholder_format.type == 7:  # Content
133 |                     content_shape = shape
134 |                 elif shape.placeholder_format.type in [18, 17, 19]:  # Picture or media placeholders
135 |                     image_placeholder = shape
136 |         
137 |         # Add title if placeholder exists
138 |         if title_shape:
139 |             title_shape.text = slide_obj.title
140 |         
141 |         # Process bullet points from section_content
142 |         bullet_points = []
143 |         if slide_obj.section_content and "," in slide_obj.section_content:
144 |             bullet_points = slide_obj.section_content.split(", ")
145 |         else:
146 |             # If no comma-separated content, try to extract bullet points from HTML
147 |             bullet_pattern = r'<div class="bullet-text">([^<]+)</div>'
148 |             bullet_matches = re.findall(bullet_pattern, slide_obj.html_content)
149 |             if bullet_matches:
150 |                 bullet_points = bullet_matches
151 |         
152 |         # Filter out empty bullet points
153 |         bullet_points = [p for p in bullet_points if p and len(p.strip()) > 0]
154 |         
155 |         # Add bullet points to content placeholder if it exists
156 |         if content_shape and bullet_points:
157 |             text_frame = content_shape.text_frame
158 |             text_frame.clear()  # Clear any default text
159 |             
160 |             # Add each bullet point
161 |             for i, point in enumerate(bullet_points):
162 |                 p = text_frame.add_paragraph()
163 |                 p.text = point
164 |                 p.level = 0  # Main bullet level
165 |         
166 |         # Extract and add image 
167 |         base64_image_pattern = r'src="data:image\/jpeg;base64,([^"]+)"'
168 |         match = re.search(base64_image_pattern, slide_obj.html_content)
169 |         
170 |         if match:
171 |             # Extract base64 image data
172 |             base64_data = match.group(1)
173 |             image_data = base64.b64decode(base64_data)
174 |             image_stream = io.BytesIO(image_data)
175 |             
176 |             # Try inserting image
177 |             if image_placeholder:
178 |                 # Insert into image placeholder if available
179 |                 try:
180 |                     image_placeholder.insert_picture(image_stream)
181 |                 except Exception as e:
182 |                     print(f"Error inserting into placeholder: {e}")
183 |                     # Fallback - add as regular shape
184 |                     image_width = Inches(4)
185 |                     image_left = prs.slide_width - image_width - Inches(0.5)
186 |                     image_top = Inches(2)
187 |                     slide.shapes.add_picture(image_stream, image_left, image_top, width=image_width)
188 |             else:
189 |                 # Add as regular shape if no placeholder
190 |                 # Position depends on whether we have content
191 |                 if content_shape:
192 |                     # If there's a content block, position image on the right
193 |                     image_width = Inches(4)
194 |                     image_left = prs.slide_width - image_width - Inches(0.5)
195 |                     image_top = Inches(2)
196 |                 else:
197 |                     # If no content, center the image
198 |                     image_width = Inches(6)
199 |                     image_left = (prs.slide_width - image_width) / 2
200 |                     image_top = (prs.slide_height - Inches(5)) / 2
201 |                 
202 |                 # Add the image
203 |                 slide.shapes.add_picture(image_stream, image_left, image_top, width=image_width)
204 |     
205 |     # Save the presentation
206 |     output = io.BytesIO()
207 |     prs.save(output)
208 |     output.seek(0)
209 |     
210 |     # Also save to file if path is provided
211 |     if output_path:
212 |         prs.save(output_path)
213 |     
214 |     return output


--------------------------------------------------------------------------------
/utils/logo_test.py:
--------------------------------------------------------------------------------
 1 | """
 2 | Utility script to test if the logo can be loaded properly.
 3 | """
 4 | import os
 5 | import base64
 6 | import sys
 7 | 
 8 | def find_logo():
 9 |     """
10 |     Try to find the logo.png file in various locations.
11 |     
12 |     Returns:
13 |         tuple: (found, path) - boolean indicating if found and path if found
14 |     """
15 |     # Possible locations to check
16 |     locations = [
17 |         os.path.join(os.getcwd(), "logo.png"),
18 |         os.path.join(os.getcwd(), "static", "logo.png"),
19 |         os.path.join(os.getcwd(), "assets", "logo.png"),
20 |         os.path.join(os.path.dirname(os.getcwd()), "logo.png")
21 |     ]
22 |     
23 |     # Check each location
24 |     for path in locations:
25 |         if os.path.exists(path):
26 |             return True, path
27 |     
28 |     return False, None
29 | 
30 | def test_logo_loading():
31 |     """
32 |     Test if the logo can be loaded and encoded properly.
33 |     """
34 |     print("Testing logo loading...")
35 |     found, path = find_logo()
36 |     
37 |     if found:
38 |         print(f"âœ… Logo found at: {path}")
39 |         try:
40 |             # Try to open and encode the logo
41 |             with open(path, "rb") as image_file:
42 |                 encoded = base64.b64encode(image_file.read()).decode()
43 |                 size = len(encoded)
44 |                 print(f"âœ… Successfully encoded logo (size: {size} bytes)")
45 |                 return True
46 |         except Exception as e:
47 |             print(f"âŒ Error encoding logo: {e}")
48 |             return False
49 |     else:
50 |         print("âŒ Logo not found in any of these locations:")
51 |         print("   - ./logo.png (project root)")
52 |         print("   - ./static/logo.png")
53 |         print("   - ./assets/logo.png")
54 |         print("   - ../ (parent directory)")
55 |         
56 |         print("\nPlease place your 'logo.png' file in one of these locations.")
57 |         return False
58 | 
59 | if __name__ == "__main__":
60 |     success = test_logo_loading()
61 |     sys.exit(0 if success else 1)


--------------------------------------------------------------------------------
/utils/openai_client.py:
--------------------------------------------------------------------------------
 1 | """
 2 | OpenAI client initialization and configuration.
 3 | """
 4 | import os
 5 | from openai import AsyncAzureOpenAI, AzureOpenAI
 6 | from agents import set_default_openai_client
 7 | 
 8 | def initialize_openai():
 9 |     """
10 |     Initialize both GPT and DALL-E clients.
11 |     
12 |     Returns:
13 |         tuple: (async_client, dalle_client) - OpenAI clients for GPT and DALL-E
14 |     """
15 |     # Initialize the AsyncAzureOpenAI client for GPT
16 |     async_client = AsyncAzureOpenAI(
17 |         api_key=os.getenv("AZURE_OPENAI_API_KEY"),
18 |         api_version=os.getenv("AZURE_OPENAI_API_VERSION"),
19 |         azure_endpoint=os.getenv("AZURE_OPENAI_ENDPOINT"),
20 |         azure_deployment=os.getenv("AZURE_OPENAI_DEPLOYMENT")
21 |     )
22 |     set_default_openai_client(async_client)
23 |     
24 |     # Create a separate client for DALL-E
25 |     dalle_client = AzureOpenAI(
26 |         api_key=os.getenv("DALLE_API_KEY"),
27 |         api_version=os.getenv("DALLE_API_VERSION", "2024-02-01"),
28 |         azure_endpoint=os.getenv("DALLE_ENDPOINT")
29 |     )
30 |     
31 |     return async_client, dalle_client
32 | 
33 | def update_openai_settings(gpt_settings, dalle_settings):
34 |     """
35 |     Update OpenAI settings in environment variables.
36 |     
37 |     Args:
38 |         gpt_settings (dict): GPT API settings
39 |         dalle_settings (dict): DALL-E API settings
40 |     """
41 |     # Update GPT settings
42 |     os.environ["AZURE_OPENAI_API_KEY"] = gpt_settings.get("api_key", "")
43 |     os.environ["AZURE_OPENAI_ENDPOINT"] = gpt_settings.get("endpoint", "")
44 |     os.environ["AZURE_OPENAI_DEPLOYMENT"] = gpt_settings.get("deployment", "")
45 |     os.environ["AZURE_OPENAI_API_VERSION"] = gpt_settings.get("api_version", "2024-02-01")
46 |     
47 |     # Update DALL-E settings
48 |     os.environ["DALLE_API_KEY"] = dalle_settings.get("api_key", "")
49 |     os.environ["DALLE_ENDPOINT"] = dalle_settings.get("endpoint", "")
50 |     os.environ["DALLE_API_VERSION"] = dalle_settings.get("api_version", "2024-02-01")
51 |     os.environ["DALLE_DEPLOYMENT"] = dalle_settings.get("deployment", "dall-e-3")


--------------------------------------------------------------------------------